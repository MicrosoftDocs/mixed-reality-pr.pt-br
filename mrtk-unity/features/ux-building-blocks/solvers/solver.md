---
title: Visão geral do solucionador
description: Visão geral do Solucionadores no MRTK
author: CDiaz-MS
ms.author: cadia
ms.date: 01/12/2021
ms.localizationpriority: high
keywords: Unity, HoloLens, HoloLens 2, Realidade Misturada, desenvolvimento, MRTK, Solucionadores,
ms.openlocfilehash: bf9bbfe578ace576fca8870f038f145037a6838d
ms.sourcegitcommit: f338b1f121a10577bcce08a174e462cdc86d5874
ms.translationtype: HT
ms.contentlocale: pt-BR
ms.lasthandoff: 07/01/2021
ms.locfileid: "113176450"
---
# <a name="solver-overview"></a><span data-ttu-id="26643-104">Visão geral do solucionador</span><span class="sxs-lookup"><span data-stu-id="26643-104">Solver overview</span></span>

![Solucionador Principal](../../images/solver/MRTK_Solver_Main.png)

<span data-ttu-id="26643-106">Os solucionadores são componentes que facilitam a forma de calcular a posição e orientação de um objeto de acordo com um algoritmo predefinido.</span><span class="sxs-lookup"><span data-stu-id="26643-106">Solvers are components that facilitate the means of calculating an object's position & orientation according to a predefined algorithm.</span></span> <span data-ttu-id="26643-107">Um exemplo pode ser a colocação de um objeto na superfície que o raycast do olhar do usuário atinge no momento.</span><span class="sxs-lookup"><span data-stu-id="26643-107">An example may be placing an object on the surface the user's gaze raycast currently hits.</span></span>

<span data-ttu-id="26643-108">Além disso, o sistema Solucionador define, de forma determinista, uma ordem de operações para esses cálculos de transformação, pois não há nenhuma maneira confiável de especificar ao Unity a ordem de atualização dos componentes.</span><span class="sxs-lookup"><span data-stu-id="26643-108">Furthermore, the Solver system deterministically defines an order of operations for these transform calculations as there is no reliable way to specify to Unity the update order for components.</span></span>

<span data-ttu-id="26643-109">Os solucionadores oferecem diversos comportamentos para anexar objetos a outros objetos ou sistemas.</span><span class="sxs-lookup"><span data-stu-id="26643-109">Solvers offer a range of behaviors to attach objects to other objects or systems.</span></span> <span data-ttu-id="26643-110">Um outro exemplo seria um objeto de marcação que focalize na frente do usuário (com base na câmera).</span><span class="sxs-lookup"><span data-stu-id="26643-110">One other example would be a tag-along object that hovers in front of the user (based on the camera).</span></span> <span data-ttu-id="26643-111">Um solucionador também pode ser anexado a um controlador e a um objeto para que o objeto seja marcado no controlador.</span><span class="sxs-lookup"><span data-stu-id="26643-111">A solver could also be attached to a controller and an object to make the object tag-along the controller.</span></span> <span data-ttu-id="26643-112">Todos os solucionadores podem ser empilhados com segurança, por exemplo, um comportamento de marcação + magnetismo de superfície + impulso.</span><span class="sxs-lookup"><span data-stu-id="26643-112">All solvers can be safely stacked, for example a tag-along behavior + surface magnetism + momentum.</span></span>

## <a name="how-to-use-a-solver"></a><span data-ttu-id="26643-113">Como usar um solucionador</span><span class="sxs-lookup"><span data-stu-id="26643-113">How to use a solver</span></span>

<span data-ttu-id="26643-114">O sistema Solucionador consiste em três categorias de scripts:</span><span class="sxs-lookup"><span data-stu-id="26643-114">The Solver system consists of three categories of scripts:</span></span>

* <span data-ttu-id="26643-115">[`Solver`](xref:Microsoft.MixedReality.Toolkit.Utilities.Solvers.Solver): a classe abstrata de base da qual todos os solucionadores derivam.</span><span class="sxs-lookup"><span data-stu-id="26643-115">[`Solver`](xref:Microsoft.MixedReality.Toolkit.Utilities.Solvers.Solver): The base abstract class that all solvers derive from.</span></span> <span data-ttu-id="26643-116">Ela fornece acompanhamento de estado, suavização de parâmetros e implementação, integração automática do sistema do solucionador e ordem de atualização.</span><span class="sxs-lookup"><span data-stu-id="26643-116">It provides state tracking, smoothing parameters and implementation, automatic solver system integration, and update order.</span></span>
* <span data-ttu-id="26643-117">[`SolverHandler`](xref:Microsoft.MixedReality.Toolkit.Utilities.Solvers.SolverHandler): define o objeto de referência a ser rastreado (por exemplo: a transformação da câmera principal, o raio de mão etc.), lida com a coleta de componentes do solucionador e os atualiza na ordem adequada.</span><span class="sxs-lookup"><span data-stu-id="26643-117">[`SolverHandler`](xref:Microsoft.MixedReality.Toolkit.Utilities.Solvers.SolverHandler): Sets the reference object to track against (ex: the main camera transform, hand ray, etc.), handles gathering of solver components, and executes updating them in the proper order.</span></span>

<span data-ttu-id="26643-118">A terceira categoria é o próprio solucionador.</span><span class="sxs-lookup"><span data-stu-id="26643-118">The third category is the solver itself.</span></span> <span data-ttu-id="26643-119">Os seguintes solucionadores fornecem os blocos de construção para o comportamento básico:</span><span class="sxs-lookup"><span data-stu-id="26643-119">The following solvers provide the building blocks for basic behavior:</span></span>

* <span data-ttu-id="26643-120">[`Orbital`](#orbital): bloqueia em uma posição e deslocamento específicos do objeto referenciado.</span><span class="sxs-lookup"><span data-stu-id="26643-120">[`Orbital`](#orbital): Locks to a specified position and offset from the referenced object.</span></span>
* <span data-ttu-id="26643-121">[`ConstantViewSize`](xref:Microsoft.MixedReality.Toolkit.Utilities.Solvers.ConstantViewSize): dimensiona para manter um tamanho constante em relação à exibição do objeto referenciado.</span><span class="sxs-lookup"><span data-stu-id="26643-121">[`ConstantViewSize`](xref:Microsoft.MixedReality.Toolkit.Utilities.Solvers.ConstantViewSize): Scales to maintain a constant size relative to the view of the referenced object.</span></span>
* <span data-ttu-id="26643-122">[`RadialView`](#radialview): mantém o objeto em uma conversão de cone de exibição pelo objeto referenciado.</span><span class="sxs-lookup"><span data-stu-id="26643-122">[`RadialView`](#radialview): Keeps the object within a view cone cast by the referenced object.</span></span>
* <span data-ttu-id="26643-123">[`Follow`](#follow): mantém o objeto dentro de um conjunto de limites definidos pelo usuário do objeto referenciado.</span><span class="sxs-lookup"><span data-stu-id="26643-123">[`Follow`](#follow): Keeps the object within a set of user defined bounds of the referenced object.</span></span>
* <span data-ttu-id="26643-124">[`InBetween`](#inbetween): mantém um objeto entre dois objetos rastreados.</span><span class="sxs-lookup"><span data-stu-id="26643-124">[`InBetween`](#inbetween): Keeps an object in between two tracked objects.</span></span>
* <span data-ttu-id="26643-125">[`SurfaceMagnetism`](#surfacemagnetism): lança raios em superfícies no mundo e alinha o objeto a essa superfície.</span><span class="sxs-lookup"><span data-stu-id="26643-125">[`SurfaceMagnetism`](#surfacemagnetism): casts rays to surfaces in the world, and align the object to that surface.</span></span>
* <span data-ttu-id="26643-126">[`DirectionalIndicator`](#directionalindicator): determina a posição e a orientação de um objeto como um indicador direcional.</span><span class="sxs-lookup"><span data-stu-id="26643-126">[`DirectionalIndicator`](#directionalindicator): Determines the position and orientation of an object as a directional indicator.</span></span> <span data-ttu-id="26643-127">Do ponto de referência do Destino Controlado do SolverHandler, esse indicador ficará em direção ao DirectionalTarget fornecido.</span><span class="sxs-lookup"><span data-stu-id="26643-127">From the point of reference of the SolverHandler Tracked Target, this indicator will orient towards the DirectionalTarget supplied.</span></span>
* <span data-ttu-id="26643-128">[`Momentum`](xref:Microsoft.MixedReality.Toolkit.Utilities.Solvers.Momentum): aplica aceleração/velocidade/atrito para simular o impulso e a elasticidade de um objeto que está sendo movido por outros solucionadores/componentes.</span><span class="sxs-lookup"><span data-stu-id="26643-128">[`Momentum`](xref:Microsoft.MixedReality.Toolkit.Utilities.Solvers.Momentum): Applies acceleration/velocity/friction to simulate momentum and springiness for an object being moved by other solvers/components.</span></span>
* <span data-ttu-id="26643-129">[`HandConstraint`](#hand-menu-with-handconstraint-and-handconstraintpalmup): restringe o objeto seguindo as mãos em uma região que não cruza o GameObject com as mãos.</span><span class="sxs-lookup"><span data-stu-id="26643-129">[`HandConstraint`](#hand-menu-with-handconstraint-and-handconstraintpalmup): Constrains object to follow hands in a region that doesn't intersect the GameObject with the hands.</span></span> <span data-ttu-id="26643-130">Útil para conteúdo interativo restrito à mão, como menus etc. Esse solucionador destina-se a trabalhar com [IMixedRealityHand](xref:Microsoft.MixedReality.Toolkit.Input.IMixedRealityHand), mas também funciona com [IMixedRealityController](xref:Microsoft.MixedReality.Toolkit.Input.IMixedRealityController).</span><span class="sxs-lookup"><span data-stu-id="26643-130">Useful for hand constrained interactive content such as menus, etc. This solver is intended to work with [IMixedRealityHand](xref:Microsoft.MixedReality.Toolkit.Input.IMixedRealityHand) but also works with [IMixedRealityController](xref:Microsoft.MixedReality.Toolkit.Input.IMixedRealityController).</span></span>
* <span data-ttu-id="26643-131">[`HandConstraintPalmUp`](#hand-menu-with-handconstraint-and-handconstraintpalmup): deriva do HandConstraint, mas inclui lógica para testar se a palma da mão está voltada para o usuário antes da ativação.</span><span class="sxs-lookup"><span data-stu-id="26643-131">[`HandConstraintPalmUp`](#hand-menu-with-handconstraint-and-handconstraintpalmup): Derives from HandConstraint but includes logic to test if the palm is facing the user before activation.</span></span> <span data-ttu-id="26643-132">Esse solucionador funciona apenas com controladores [IMixedRealityHand](xref:Microsoft.MixedReality.Toolkit.Input.IMixedRealityHand). Com outros tipos de controlador, esse solucionador se comportará exatamente como sua classe base.</span><span class="sxs-lookup"><span data-stu-id="26643-132">This solver only works with [IMixedRealityHand](xref:Microsoft.MixedReality.Toolkit.Input.IMixedRealityHand) controllers, with other controller types this solver will behave just like its base class.</span></span>

<span data-ttu-id="26643-133">Para usar o sistema do Solucionador, basta adicionar um dos componentes listados acima a um GameObject.</span><span class="sxs-lookup"><span data-stu-id="26643-133">In order to use the Solver system, simply add one of the components listed above to a GameObject.</span></span> <span data-ttu-id="26643-134">Como todos os Solucionadores exigem [`SolverHandler`](xref:Microsoft.MixedReality.Toolkit.Utilities.Solvers.SolverHandler), um será criado automaticamente pelo Unity.</span><span class="sxs-lookup"><span data-stu-id="26643-134">Since all Solvers require a [`SolverHandler`](xref:Microsoft.MixedReality.Toolkit.Utilities.Solvers.SolverHandler), one will be created automatically by Unity.</span></span>

> [!NOTE]
> <span data-ttu-id="26643-135">Exemplos de como usar o sistema de Solucionadores podem ser encontrados no arquivo **SolverExamples.scene**.</span><span class="sxs-lookup"><span data-stu-id="26643-135">Examples of how to use the Solvers system can be found in the **SolverExamples.scene** file.</span></span>

## <a name="how-to-change-tracking-reference"></a><span data-ttu-id="26643-136">Como alterar a referência de acompanhamento</span><span class="sxs-lookup"><span data-stu-id="26643-136">How to change tracking reference</span></span>

<span data-ttu-id="26643-137">A propriedade *Tipo de Destino Controlado* do componente [`SolverHandler`](xref:Microsoft.MixedReality.Toolkit.Utilities.Solvers.SolverHandler) define o ponto de referência que todos os solucionadores usarão para calcular seus algoritmos.</span><span class="sxs-lookup"><span data-stu-id="26643-137">The *Tracked Target Type* property of the [`SolverHandler`](xref:Microsoft.MixedReality.Toolkit.Utilities.Solvers.SolverHandler) component defines the point of reference all solvers will use to calculate their algorithms.</span></span> <span data-ttu-id="26643-138">Por exemplo, um tipo de valor de [`Head`](xref:Microsoft.MixedReality.Toolkit.Utilities.TrackedObjectType.Head) com um componente [`SurfaceMagnetism`](xref:Microsoft.MixedReality.Toolkit.Utilities.Solvers.SurfaceMagnetism) simples, resultará em um raycast da cabeça e na direção do olhar do usuário para resolver qual superfície é atingida.</span><span class="sxs-lookup"><span data-stu-id="26643-138">For example, a value type of [`Head`](xref:Microsoft.MixedReality.Toolkit.Utilities.TrackedObjectType.Head) with a simple [`SurfaceMagnetism`](xref:Microsoft.MixedReality.Toolkit.Utilities.Solvers.SurfaceMagnetism) component will result in a raycast from the head and in the direction of the user's gaze for solving what surface is hit.</span></span> <span data-ttu-id="26643-139">Valores potenciais para a propriedade `TrackedTargetType` são:</span><span class="sxs-lookup"><span data-stu-id="26643-139">Potential values for the `TrackedTargetType` property are:</span></span>

* <span data-ttu-id="26643-140">*Head*: o ponto de referência é a transformação da câmera principal</span><span class="sxs-lookup"><span data-stu-id="26643-140">*Head* : Point of reference is the transform of the main camera</span></span>
* <span data-ttu-id="26643-141">*ControllerRay*: o ponto de referência é a transformação [`LinePointer`](xref:Microsoft.MixedReality.Toolkit.Input.LinePointer) em um controlador (ou seja,</span><span class="sxs-lookup"><span data-stu-id="26643-141">*ControllerRay*: Point of reference is the [`LinePointer`](xref:Microsoft.MixedReality.Toolkit.Input.LinePointer) transform on a controller (i.e</span></span> <span data-ttu-id="26643-142">origem do ponteiro em um controlador de movimentos ou controlador de mão) apontando na direção do raio de linha</span><span class="sxs-lookup"><span data-stu-id="26643-142">pointer origin on a motion controller or hand controller) pointing in the direction of the line ray</span></span>
  * <span data-ttu-id="26643-143">Use a propriedade `TrackedHandedness` para selecionar a preferência de destro/canhoto (ou seja,</span><span class="sxs-lookup"><span data-stu-id="26643-143">Use the `TrackedHandedness` property to select the handedness preference (i.e</span></span> <span data-ttu-id="26643-144">Esquerda, Direita, Ambas)</span><span class="sxs-lookup"><span data-stu-id="26643-144">Left, Right, Both)</span></span>
* <span data-ttu-id="26643-145">*HandJoint*: o ponto de referência é a transformação de uma articulação da mão específica</span><span class="sxs-lookup"><span data-stu-id="26643-145">*HandJoint*: Point of reference is the transform of a specific hand joint</span></span>
  * <span data-ttu-id="26643-146">Use a propriedade `TrackedHandedness` para selecionar a preferência de destro/canhoto (ou seja,</span><span class="sxs-lookup"><span data-stu-id="26643-146">Use the `TrackedHandedness` property to select the handedness preference (i.e</span></span> <span data-ttu-id="26643-147">Esquerda, Direita, Ambas)</span><span class="sxs-lookup"><span data-stu-id="26643-147">Left, Right, Both)</span></span>
  * <span data-ttu-id="26643-148">Use a propriedade `TrackedHandJoint` para determinar a transformação da articulação a ser utilizada</span><span class="sxs-lookup"><span data-stu-id="26643-148">Use the  `TrackedHandJoint` property to determine the joint transform to utilize</span></span>
* <span data-ttu-id="26643-149">*CustomOverride*: ponto de referência do `TransformOverride` atribuído</span><span class="sxs-lookup"><span data-stu-id="26643-149">*CustomOverride*: Point of reference from the assigned `TransformOverride`</span></span>

> [!NOTE]
> <span data-ttu-id="26643-150">Para os tipos *ControllerRay* e *HandJoint,* o manipulador do solucionador tentará fornecer primeiro a transformação do controlador/mão esquerda e, em seguida, a direita se a primeira não estiver disponível ou a menos que a propriedade `TrackedHandedness` especifique o contrário.</span><span class="sxs-lookup"><span data-stu-id="26643-150">For both *ControllerRay* and *HandJoint* types, the solver handler will attempt to provide the left controller/hand transform first and then the right if the former is not available or unless the `TrackedHandedness` property specifies otherwise.</span></span>

<span data-ttu-id="26643-151">![Objeto Acompanhado do Solucionador](../../images/solver/TrackedObjectType-Example.gif) 
*Exemplo de várias propriedades associadas a cada TrackedTargetType*</span><span class="sxs-lookup"><span data-stu-id="26643-151">![Solver Tracked Object](../../images/solver/TrackedObjectType-Example.gif) 
*Example of various properties associated with each TrackedTargetType*</span></span>

> [!IMPORTANT]
> <span data-ttu-id="26643-152">A maioria dos solucionadores usa o vetor de destino da transformação acompanhada fornecido por `SolverHandler`.</span><span class="sxs-lookup"><span data-stu-id="26643-152">Most solvers use the forward vector of the tracked transform target supplied by the `SolverHandler`.</span></span> <span data-ttu-id="26643-153">Ao usar um tipo de destino acompanhado da *Articulação da Mão*, o vetor de avanço da articulação da palma da mão pode apontar pelos dedos e não pela palma da mão.</span><span class="sxs-lookup"><span data-stu-id="26643-153">When using a *Hand Joint* tracked target type, the forward vector of the palm joint may point through the fingers and not through the palm.</span></span> <span data-ttu-id="26643-154">Isso depende da plataforma que fornece os dados da articulação da mão.</span><span class="sxs-lookup"><span data-stu-id="26643-154">This depends on the platform supplying the hand joint data.</span></span> <span data-ttu-id="26643-155">Para simulação de entrada e Windows Mixed Reality, o *vetor de ascensão* aponta para cima através da palma da mão (ou seja,</span><span class="sxs-lookup"><span data-stu-id="26643-155">For input simulation and Windows Mixed Reality, it is the *up vector* that points up through the palm (i.e</span></span> <span data-ttu-id="26643-156">vetor verde para cima, vetor azul para frente).</span><span class="sxs-lookup"><span data-stu-id="26643-156">green vector is up, blue vector is forward).</span></span>
>
> ![Vetor de ascensão de avanço](../../images/solver/HandJoint_ForwardUpVectors.png)
>
> <span data-ttu-id="26643-158">Para resolver isso, atualize a propriedade de *Rotação Adicional* no `SolverHandler` para **<90, 0, 0>** .</span><span class="sxs-lookup"><span data-stu-id="26643-158">To overcome this, update the *Additional Rotation* property on the `SolverHandler` to **<90, 0, 0>**.</span></span> <span data-ttu-id="26643-159">Isso garantirá que o vetor de avanço fornecido aos solucionadores está apontando pela palma da mão e para fora na direção contrária da mão.</span><span class="sxs-lookup"><span data-stu-id="26643-159">This will ensure the forward vector supplied to solvers is pointing through the palm and outward away from the hand.</span></span>
>
> ![Rotação Adicional](../../images/solver/SolverHandler_AdditionalRotation.png)
>
> <span data-ttu-id="26643-161">Como alternativa, use o tipo de destino controlado *Raio do Controlador* para obter um comportamento semelhante ao apontar com as mãos.</span><span class="sxs-lookup"><span data-stu-id="26643-161">Alternatively, use the *Controller Ray* tracked target type to get similar behavior for pointing with hands.</span></span>

## <a name="how-to-chain-solvers"></a><span data-ttu-id="26643-162">Como encadear solucionadores</span><span class="sxs-lookup"><span data-stu-id="26643-162">How to chain solvers</span></span>

<span data-ttu-id="26643-163">É possível adicionar vários componentes `Solver` ao mesmo GameObject encadeando seus algoritmos.</span><span class="sxs-lookup"><span data-stu-id="26643-163">It is possible to add multiple `Solver` components to the same GameObject thus chaining their algorithms.</span></span> <span data-ttu-id="26643-164">Os componentes `SolverHandler` lidam com a atualização de todos os solucionadores no mesmo GameObject.</span><span class="sxs-lookup"><span data-stu-id="26643-164">The `SolverHandler` components handles updating all solvers on the same GameObject.</span></span> <span data-ttu-id="26643-165">Por padrão, as `SolverHandler` chamadas `GetComponents<Solver>()` em Iniciar retornarão os Solucionadores na ordem em que aparecem no inspetor.</span><span class="sxs-lookup"><span data-stu-id="26643-165">By default the `SolverHandler` calls `GetComponents<Solver>()` on Start which will return the Solvers in the order that they appear in the inspector.</span></span>

<span data-ttu-id="26643-166">Além disso, definir a propriedade *Transformação Vinculada Atualizada* como verdadeiro, instrui `Solver` a salvar sua posição calculada, orientação e escala em uma variável intermediária acessível por todos os Solucionadores (ou seja,</span><span class="sxs-lookup"><span data-stu-id="26643-166">Furthermore, setting the *Updated Linked Transform* property to true will instruct that `Solver` to save its calculated position, orientation, & scale to an intermediary variable accessible by all Solvers (i.e</span></span> <span data-ttu-id="26643-167">`GoalPosition`).</span><span class="sxs-lookup"><span data-stu-id="26643-167">`GoalPosition`).</span></span> <span data-ttu-id="26643-168">Se definida como falso, `Solver` atualizará a transformação do GameObject diretamente.</span><span class="sxs-lookup"><span data-stu-id="26643-168">When false, the `Solver` will update the GameObject's transform directly.</span></span> <span data-ttu-id="26643-169">Ao salvar as propriedades de transformação em um local intermediário, outros Solucionadores podem executar seus cálculos começando na variável intermediária.</span><span class="sxs-lookup"><span data-stu-id="26643-169">By saving the transform properties to an intermediary location, other Solvers are able to perform their calculations starting from the intermediary variable.</span></span> <span data-ttu-id="26643-170">Isso acontece porque o Unity não permite que as atualizações no gameObject.transform sejam empilhadas dentro do mesmo quadro.</span><span class="sxs-lookup"><span data-stu-id="26643-170">This is because Unity does not allow updates to gameObject.transform to stack within the same frame.</span></span>

> [!NOTE]
> <span data-ttu-id="26643-171">Os desenvolvedores podem modificar a ordem de execução dos Solucionadores definindo a propriedade `SolverHandler.Solvers` diretamente.</span><span class="sxs-lookup"><span data-stu-id="26643-171">Developers can modify the order of execution of Solvers by setting the `SolverHandler.Solvers` property directly.</span></span>

## <a name="how-to-create-a-new-solver"></a><span data-ttu-id="26643-172">Como criar um novo solucionador</span><span class="sxs-lookup"><span data-stu-id="26643-172">How to create a new solver</span></span>

<span data-ttu-id="26643-173">Todos os solucionadores devem herdar da classe base abstrata, [`Solver`](xref:Microsoft.MixedReality.Toolkit.Utilities.Solvers.Solver).</span><span class="sxs-lookup"><span data-stu-id="26643-173">All solvers must inherit from the abstract base class, [`Solver`](xref:Microsoft.MixedReality.Toolkit.Utilities.Solvers.Solver).</span></span> <span data-ttu-id="26643-174">Os principais requisitos de uma extensão do Solucionador envolvem a substituição do método `SolverUpdate`.</span><span class="sxs-lookup"><span data-stu-id="26643-174">The primary requirements of a Solver extension involves overriding the `SolverUpdate` method.</span></span> <span data-ttu-id="26643-175">Nesse método, os desenvolvedores devem atualizar as propriedades herdadas `GoalPosition`, `GoalRotation` e `GoalScale` para os valores desejados.</span><span class="sxs-lookup"><span data-stu-id="26643-175">In this method, developers should update the inherited `GoalPosition`, `GoalRotation` and `GoalScale` properties to the desired values.</span></span> <span data-ttu-id="26643-176">Além disso, geralmente é valioso aproveitar `SolverHandler.TransformTarget` como o quadro de referência desejado pelo consumidor.</span><span class="sxs-lookup"><span data-stu-id="26643-176">Furthermore, it is generally valuable to leverage `SolverHandler.TransformTarget` as the frame of reference desired by the consumer.</span></span>

<span data-ttu-id="26643-177">O código fornecido abaixo fornece um exemplo de um novo componente Solucionador chamado `InFront` que coloca o objeto anexado 2m na frente do `SolverHandler.TransformTarget`.</span><span class="sxs-lookup"><span data-stu-id="26643-177">The code provided below gives an example of a new Solver component called `InFront` that places the attached object 2m in front of the `SolverHandler.TransformTarget`.</span></span> <span data-ttu-id="26643-178">Se `SolverHandler.TrackedTargetType` for definido pelo consumidor como [`Head`](xref:Microsoft.MixedReality.Toolkit.Utilities.TrackedObjectType.Head), o `SolverHandler.TransformTarget` será a transformação da câmera e, portanto, esse Solucionador colocará o GameObject anexado a 2m na frente do olhar dos usuários a cada quadro.</span><span class="sxs-lookup"><span data-stu-id="26643-178">If the `SolverHandler.TrackedTargetType` is set by the consumer as [`Head`](xref:Microsoft.MixedReality.Toolkit.Utilities.TrackedObjectType.Head), then the `SolverHandler.TransformTarget` will be the camera transform and thus this Solver will place the attached GameObject 2m in front of the users' gaze every frame.</span></span>

```c#
/// <summary>
/// InFront solver positions an object 2m in front of the tracked transform target
/// </summary>
public class InFront : Solver
{
    ...

    public override void SolverUpdate()
    {
        if (SolverHandler != null && SolverHandler.TransformTarget != null)
        {
            var target = SolverHandler.TransformTarget;
            GoalPosition = target.position + target.forward * 2.0f;
        }
    }
}
```

## <a name="solver-implementation-guides"></a><span data-ttu-id="26643-179">Guias de implementação do solucionador</span><span class="sxs-lookup"><span data-stu-id="26643-179">Solver implementation guides</span></span>

### <a name="common-solver-properties"></a><span data-ttu-id="26643-180">Propriedades comuns do solucionador</span><span class="sxs-lookup"><span data-stu-id="26643-180">Common solver properties</span></span>

<span data-ttu-id="26643-181">Cada componente do Solucionador tem um conjunto principal de propriedades idênticas que controlam o comportamento principal do Solucionador.</span><span class="sxs-lookup"><span data-stu-id="26643-181">Every Solver component has a core-set of identical properties that control the core Solver behavior.</span></span>

<span data-ttu-id="26643-182">Se a *Suavização* estiver habilitada, o Solucionador atualizará gradualmente a transformação do GameObject ao longo do tempo de acordo com os valores calculados.</span><span class="sxs-lookup"><span data-stu-id="26643-182">If *Smoothing* is enabled, then the Solver will gradually update the transform of the GameObject over time to the calculated values.</span></span> <span data-ttu-id="26643-183">A velocidade dessa alteração é determinada pela propriedade *LerpTime* de cada componente da transformação.</span><span class="sxs-lookup"><span data-stu-id="26643-183">The speed of this change is determined by every transform component's *LerpTime* property.</span></span> <span data-ttu-id="26643-184">Por exemplo, um valor *MoveLerpTime* mais alto resultará em incrementos mais lentos na movimentação entre quadros.</span><span class="sxs-lookup"><span data-stu-id="26643-184">For example, a higher *MoveLerpTime* value will result in slower increments in movement between frames.</span></span>

<span data-ttu-id="26643-185">Se *MaintainScale* estiver habilitado, o Solucionador utilizará a escala local padrão do GameObject.</span><span class="sxs-lookup"><span data-stu-id="26643-185">If *MaintainScale* is enabled, then the Solver will utilize the GameObject's default local scale.</span></span>

<span data-ttu-id="26643-186">![Propriedades do Solucionador Principal](../../images/solver/GeneralSolverProperties.png)</span><span class="sxs-lookup"><span data-stu-id="26643-186">![Core Solver Properties](../../images/solver/GeneralSolverProperties.png)</span></span>  
<span data-ttu-id="26643-187">*Propriedades comuns herdadas por todos os componentes do Solucionador*</span><span class="sxs-lookup"><span data-stu-id="26643-187">*Common properties inherited by all Solver components*</span></span>

### <a name="orbital"></a><span data-ttu-id="26643-188">Orbital</span><span class="sxs-lookup"><span data-stu-id="26643-188">Orbital</span></span>

<span data-ttu-id="26643-189">A classe [`Orbital`](xref:Microsoft.MixedReality.Toolkit.Utilities.Solvers.Orbital) é um componente de marcação que se comporta como planetas em um sistema solar.</span><span class="sxs-lookup"><span data-stu-id="26643-189">The [`Orbital`](xref:Microsoft.MixedReality.Toolkit.Utilities.Solvers.Orbital) class is a tag-along component that behaves like planets in a solar system.</span></span> <span data-ttu-id="26643-190">Esse Solucionador garantirá que o GameObject anexado orbite ao redor da transformação acompanhada.</span><span class="sxs-lookup"><span data-stu-id="26643-190">This Solver will ensure the attached GameObject orbits around the tracked transform.</span></span> <span data-ttu-id="26643-191">Portanto, se o *Tipo de Destino Acompanhado* do [`SolverHandler`](xref:Microsoft.MixedReality.Toolkit.Utilities.Solvers.SolverHandler) estiver definido como [`Head`](xref:Microsoft.MixedReality.Toolkit.Utilities.TrackedObjectType.Head), o GameObject irá orbitar ao redor da cabeça do usuário com um deslocamento fixo aplicado.</span><span class="sxs-lookup"><span data-stu-id="26643-191">Thus, if the *Tracked Target Type* of the [`SolverHandler`](xref:Microsoft.MixedReality.Toolkit.Utilities.Solvers.SolverHandler) is set to [`Head`](xref:Microsoft.MixedReality.Toolkit.Utilities.TrackedObjectType.Head), then the GameObject will orbit around the user's head with a fixed offset applied.</span></span>

<span data-ttu-id="26643-192">Os desenvolvedores podem modificar esse deslocamento fixo para manter os menus ou outros componentes de cena ao nível dos olhos ou ao nível da inclinação etc. em torno de um usuário.</span><span class="sxs-lookup"><span data-stu-id="26643-192">Developers can modify this fixed offset to keep menus or other scene components at eye-level or at waist level etc. around a user.</span></span> <span data-ttu-id="26643-193">Isso é feito modificando as propriedades *Deslocamento Local* e *Deslocamento Mundial*.</span><span class="sxs-lookup"><span data-stu-id="26643-193">This is done by modifying the *Local Offset* and *World Offset* properties.</span></span> <span data-ttu-id="26643-194">A propriedade *Tipo de Orientação* determina a rotação aplicada ao objeto se ele mantiver sua rotação original ou sempre ficar voltado para a câmera ou para qualquer transformação que estiver impulsionando sua posição etc.</span><span class="sxs-lookup"><span data-stu-id="26643-194">The *Orientation Type* property determines the rotation applied to the object if it should maintain its original rotation or always face the camera or face whatever transform is driving its position etc.</span></span>

<span data-ttu-id="26643-195">![Exemplo do Orbital](../../images/solver/OrbitalExample.png)</span><span class="sxs-lookup"><span data-stu-id="26643-195">![Orbital Example](../../images/solver/OrbitalExample.png)</span></span>  
<span data-ttu-id="26643-196">*Exemplo do Orbital*</span><span class="sxs-lookup"><span data-stu-id="26643-196">*Orbital example*</span></span>

### <a name="radialview"></a><span data-ttu-id="26643-197">RadialView</span><span class="sxs-lookup"><span data-stu-id="26643-197">RadialView</span></span>

<span data-ttu-id="26643-198">O [`RadialView`](xref:Microsoft.MixedReality.Toolkit.Utilities.Solvers.RadialView) é outro componente de marcação que mantém uma parte específica de um GameObject dentro do tronco de exibição do usuário.</span><span class="sxs-lookup"><span data-stu-id="26643-198">The [`RadialView`](xref:Microsoft.MixedReality.Toolkit.Utilities.Solvers.RadialView) is another tag-along component that keeps a particular portion of a GameObject within the frustum of the user's view.</span></span>

<span data-ttu-id="26643-199">As propriedades *Grau de Exibição Mínimo e Máximo* determinam o tamanho de uma parte do GameObject que sempre deve estar em exibição.</span><span class="sxs-lookup"><span data-stu-id="26643-199">The *Min & Max View Degrees* properties determines how large of a portion of the GameObject must always be in view.</span></span>

<span data-ttu-id="26643-200">As propriedades *Distância Mínima e Máxima* determinam a distância na qual o GameObject deve ser mantido do usuário.</span><span class="sxs-lookup"><span data-stu-id="26643-200">The *Min & Max Distance* properties determines how far the GameObject should be kept from the user.</span></span> <span data-ttu-id="26643-201">Por exemplo, andar na direção do GameObject com uma *Distância Mínima* de 1m fará com que o GameObject nunca esteja a menos de 1m do usuário.</span><span class="sxs-lookup"><span data-stu-id="26643-201">For example, walking towards the GameObject with a *Min Distance* of 1m will push the GameObject away to ensure it is never closer than 1m to the user.</span></span>

<span data-ttu-id="26643-202">Geralmente, o [`RadialView`](xref:Microsoft.MixedReality.Toolkit.Utilities.Solvers.RadialView) é usado em conjunto com o *Tipo de Destino Controlado* definido como [`Head`](xref:Microsoft.MixedReality.Toolkit.Utilities.TrackedObjectType.Head) para que o componente siga o olhar do usuário.</span><span class="sxs-lookup"><span data-stu-id="26643-202">Generally, the [`RadialView`](xref:Microsoft.MixedReality.Toolkit.Utilities.Solvers.RadialView) is used in conjunction with *Tracked Target Type* set to [`Head`](xref:Microsoft.MixedReality.Toolkit.Utilities.TrackedObjectType.Head) so that the component follows the user's gaze.</span></span> <span data-ttu-id="26643-203">No entanto, esse componente pode funcionar para ser mantido em *"exibição"* de qualquer *Tipo de Destino Controlado*.</span><span class="sxs-lookup"><span data-stu-id="26643-203">However, this component can function to be kept in *"view"* of any *Tracked Target Type*.</span></span>

<span data-ttu-id="26643-204">![Exemplo de RadialView](../../images/solver/RadialViewExample.png)</span><span class="sxs-lookup"><span data-stu-id="26643-204">![RadialView Example](../../images/solver/RadialViewExample.png)</span></span>  
<span data-ttu-id="26643-205">*Exemplo de RadialView*</span><span class="sxs-lookup"><span data-stu-id="26643-205">*RadialView example*</span></span>

### <a name="follow"></a><span data-ttu-id="26643-206">Seguir</span><span class="sxs-lookup"><span data-stu-id="26643-206">Follow</span></span>

<span data-ttu-id="26643-207">A classe [`Follow`](xref:Microsoft.MixedReality.Toolkit.Utilities.Solvers.Follow) posiciona um elemento na frente do destino controlado em relação ao eixo dianteiro local.</span><span class="sxs-lookup"><span data-stu-id="26643-207">The [`Follow`](xref:Microsoft.MixedReality.Toolkit.Utilities.Solvers.Follow) class positions an element in front of the of the tracked target relative to its local forward axis.</span></span> <span data-ttu-id="26643-208">O elemento pode ser restrito de forma flexível (também conhecido como</span><span class="sxs-lookup"><span data-stu-id="26643-208">The element can be loosely constrained (a.k.a.</span></span> <span data-ttu-id="26643-209">marcação) para que ele não siga até que o destino controlado se mova além dos limites definidos pelo usuário.</span><span class="sxs-lookup"><span data-stu-id="26643-209">tag-along) so that it doesn't follow until the tracked target moves beyond user defined bounds.</span></span>

<span data-ttu-id="26643-210">Ele funciona da mesma forma que o solucionador RadialView, com controles adicionais para gerenciar *Grau de Exibição Máximo Horizontal e Vertical*, e mecanismos para alterar a *Orientação* do objeto.</span><span class="sxs-lookup"><span data-stu-id="26643-210">It works similarly to the RadialView solver, with additional controls to manage *Max Horizontal & Vertical View Degrees*, and mechanisms to alter the *Orientation* of the object.</span></span>

<span data-ttu-id="26643-211">![Siga as propriedades](../../images/solver/FollowExample.png)</span><span class="sxs-lookup"><span data-stu-id="26643-211">![Follow properties](../../images/solver/FollowExample.png)</span></span>  
<span data-ttu-id="26643-212">*Siga as propriedades*</span><span class="sxs-lookup"><span data-stu-id="26643-212">*Follow properties*</span></span>

<span data-ttu-id="26643-213">![Siga a cena de exemplo](../../images/solver/FollowExampleScene.gif)</span><span class="sxs-lookup"><span data-stu-id="26643-213">![Follow example scene](../../images/solver/FollowExampleScene.gif)</span></span>  
<span data-ttu-id="26643-214">*Siga a Cena de Exemplo (Assets/MRTK/Examples/Demos/Solvers/Scenes/FollowSolverExample.unity)*</span><span class="sxs-lookup"><span data-stu-id="26643-214">*Follow Example Scene (Assets/MRTK/Examples/Demos/Solvers/Scenes/FollowSolverExample.unity)*</span></span>

### <a name="inbetween"></a><span data-ttu-id="26643-215">InBetween</span><span class="sxs-lookup"><span data-stu-id="26643-215">InBetween</span></span>

<span data-ttu-id="26643-216">A classe [`InBetween`](xref:Microsoft.MixedReality.Toolkit.Utilities.Solvers.InBetween) manterá o GameObject anexado entre duas transformações.</span><span class="sxs-lookup"><span data-stu-id="26643-216">The [`InBetween`](xref:Microsoft.MixedReality.Toolkit.Utilities.Solvers.InBetween) class will keep the attached GameObject between two transforms.</span></span> <span data-ttu-id="26643-217">Esses dois pontos de extremidade de transformação são definidos pelo próprio [`SolverHandler`](xref:Microsoft.MixedReality.Toolkit.Utilities.Solvers.SolverHandler)*Tipo de Destino Controlado* do GameObject e pela propriedade do [`InBetween`](xref:Microsoft.MixedReality.Toolkit.Utilities.Solvers.InBetween)*Segundo Tipo de Destino Controlado* do componente.</span><span class="sxs-lookup"><span data-stu-id="26643-217">These two transform endpoints are defined by the GameObject's own [`SolverHandler`](xref:Microsoft.MixedReality.Toolkit.Utilities.Solvers.SolverHandler) *Tracked Target Type* and the [`InBetween`](xref:Microsoft.MixedReality.Toolkit.Utilities.Solvers.InBetween) component's *Second Tracked Target Type* property.</span></span> <span data-ttu-id="26643-218">Em geral, ambos os tipos serão definidos como [`CustomOverride`](xref:Microsoft.MixedReality.Toolkit.Utilities.TrackedObjectType.CustomOverride) e os valores `SolverHandler.TransformOverride` e `InBetween.SecondTransformOverride` resultantes definidos como os dois pontos de extremidade controlados.</span><span class="sxs-lookup"><span data-stu-id="26643-218">Generally, both types will be set to [`CustomOverride`](xref:Microsoft.MixedReality.Toolkit.Utilities.TrackedObjectType.CustomOverride) and the resulting `SolverHandler.TransformOverride` and `InBetween.SecondTransformOverride` values set to the two tracked endpoints.</span></span>

<span data-ttu-id="26643-219">No tempo de execução, o componente [`InBetween`](xref:Microsoft.MixedReality.Toolkit.Utilities.Solvers.InBetween) criará outro componente [`SolverHandler`](xref:Microsoft.MixedReality.Toolkit.Utilities.Solvers.SolverHandler) com base nas propriedades do *Segundo Tipo de Destino Controlado* e *Segunda Substituição de Transformação*.</span><span class="sxs-lookup"><span data-stu-id="26643-219">At runtime, the [`InBetween`](xref:Microsoft.MixedReality.Toolkit.Utilities.Solvers.InBetween) component will create another [`SolverHandler`](xref:Microsoft.MixedReality.Toolkit.Utilities.Solvers.SolverHandler) component based on the *Second Tracked Target Type* and *Second Transform Override* properties.</span></span>

<span data-ttu-id="26643-220">`PartwayOffset` define onde, na linha entre duas transformações, o objeto deve ser colocado com 0,5 como a metade, 1,0 na primeira transformação e 0,0 na segunda transformação.</span><span class="sxs-lookup"><span data-stu-id="26643-220">The `PartwayOffset` defines where along the line between two transforms the object shall be placed with 0.5 as halfway, 1.0 at the first transform, and 0.0 at the second transform.</span></span>

<span data-ttu-id="26643-221">![Exemplo de InBetween](../../images/solver/InBetweenExample.png)</span><span class="sxs-lookup"><span data-stu-id="26643-221">![InBetween Example](../../images/solver/InBetweenExample.png)</span></span>  
<span data-ttu-id="26643-222">*Exemplo de uso do solucionador InBetween para manter o objeto entre duas transformações*</span><span class="sxs-lookup"><span data-stu-id="26643-222">*Example of using InBetween solver to keep object between two transforms*</span></span>

### <a name="surfacemagnetism"></a><span data-ttu-id="26643-223">SurfaceMagnetism</span><span class="sxs-lookup"><span data-stu-id="26643-223">SurfaceMagnetism</span></span>

<span data-ttu-id="26643-224">[`SurfaceMagnetism`](xref:Microsoft.MixedReality.Toolkit.Utilities.Solvers.SurfaceMagnetism) funciona executando um raycast em um LayerMask definido de superfícies, e colocando o GameObject nesse ponto de contato.</span><span class="sxs-lookup"><span data-stu-id="26643-224">The [`SurfaceMagnetism`](xref:Microsoft.MixedReality.Toolkit.Utilities.Solvers.SurfaceMagnetism) works by performing a raycast against a set LayerMask of surfaces and placing the GameObject at that point of contact.</span></span>

<span data-ttu-id="26643-225">O *Deslocamento Normal da Superfície* colocará o GameObject a uma distância definida em metros de distância da superfície na direção do normal no ponto de clique na superfície.</span><span class="sxs-lookup"><span data-stu-id="26643-225">The *Surface Normal Offset* will place the GameObject a set distance in meters away from the surface in the direction of the normal at the hit point on the surface.</span></span>

<span data-ttu-id="26643-226">Por outro lado, o *Deslocamento do Raio de Superfície* colocará o GameObject a uma distância definida em metros de distância da superfície, mas na direção contrária do raycast executado.</span><span class="sxs-lookup"><span data-stu-id="26643-226">Conversely, the *Surface Ray Offset* will place the GameObject a set distance in meters away from the surface but in the opposite direction of the raycast performed.</span></span> <span data-ttu-id="26643-227">Portanto, se o raycast for o olhar do usuário, o GameObject se aproximará ao longo da linha do ponto de clique na superfície para a câmera.</span><span class="sxs-lookup"><span data-stu-id="26643-227">Thus, if the raycast is the user's gaze, then the GameObject will move closer along the line from the hit point on the surface to the camera.</span></span>

<span data-ttu-id="26643-228">O *Modo de Orientação* determina o tipo de rotação a ser aplicada em relação ao normal na superfície.</span><span class="sxs-lookup"><span data-stu-id="26643-228">The *Orientation Mode* determines the type of rotation to apply in relation to the normal on the surface.</span></span>

* <span data-ttu-id="26643-229">*None* – nenhuma rotação aplicada</span><span class="sxs-lookup"><span data-stu-id="26643-229">*None* - No rotation applied</span></span>
* <span data-ttu-id="26643-230">*TrackedTarget* – o objeto ficará voltado para a transformação controlada executando o raycast</span><span class="sxs-lookup"><span data-stu-id="26643-230">*TrackedTarget* - Object will face the tracked transform driving the raycast</span></span>
* <span data-ttu-id="26643-231">*SurfaceNormal* – o objeto será alinhado com base no normal no ponto de clique na superfície</span><span class="sxs-lookup"><span data-stu-id="26643-231">*SurfaceNormal* - Object will align based on normal at hit point on surface</span></span>
* <span data-ttu-id="26643-232">*Blended* – o objeto será alinhado com base no normal no ponto de clique na superfície E com base na transformação controlada.</span><span class="sxs-lookup"><span data-stu-id="26643-232">*Blended* - Object will align based on normal at hit point on surface AND based on facing the tracked transform.</span></span>

<span data-ttu-id="26643-233">Para forçar o GameObject associado a permanecer na vertical em qualquer modo diferente de *None*, habilite *Manter Orientação Vertical*.</span><span class="sxs-lookup"><span data-stu-id="26643-233">To force the associated GameObject to stay vertical in any mode other than *None*, enable *Keep Orientation Vertical*.</span></span>

> [!NOTE]
> <span data-ttu-id="26643-234">Use a propriedade *Combinação de Orientação* para controlar o equilíbrio entre os fatores de rotação quando o *Modo de Orientação* for definido como *Blended*.</span><span class="sxs-lookup"><span data-stu-id="26643-234">Use the *Orientation Blend* property to control the balance between rotation factors when *Orientation Mode* is set to *Blended*.</span></span> <span data-ttu-id="26643-235">A orientação do valor de 0,0 será totalmente determinada pelo modo *TrackedTarget*, e a orientação do valor de 1,0 será totalmente determinada por *SurfaceNormal*.</span><span class="sxs-lookup"><span data-stu-id="26643-235">A value of 0.0 will have orientation entirely driven by *TrackedTarget* mode and a value of 1.0 will have orientation driven entirely by *SurfaceNormal*.</span></span>

![Exemplo de SurfaceMagtism](../../images/solver/SurfaceMagExample.png)

#### <a name="determining-what-surfaces-can-be-hit"></a><span data-ttu-id="26643-237">Determinando quais superfícies podem ser atingidas</span><span class="sxs-lookup"><span data-stu-id="26643-237">Determining what surfaces can be hit</span></span>

<span data-ttu-id="26643-238">Ao adicionar um componente [`SurfaceMagnetism`](xref:Microsoft.MixedReality.Toolkit.Utilities.Solvers.SurfaceMagnetism) a um GameObject, é importante considerar a camada do GameObject e seus filhos, se algum tiver colisores.</span><span class="sxs-lookup"><span data-stu-id="26643-238">When adding a [`SurfaceMagnetism`](xref:Microsoft.MixedReality.Toolkit.Utilities.Solvers.SurfaceMagnetism) component to a GameObject, it is important to consider the layer of the GameObject and its children, if any have colliders.</span></span> <span data-ttu-id="26643-239">O componente funciona executando vários tipos de raycasts para determinar em qual superfície deverá se "atrair".</span><span class="sxs-lookup"><span data-stu-id="26643-239">The component works by performing various types of raycasts to determine what surface to "magnet" itself against.</span></span> <span data-ttu-id="26643-240">Se o solucionador GameObject tiver um colisor em uma das camadas listadas na propriedade `MagneticSurfaces` de `SurfaceMagnetism`, o raycast provavelmente se atingirá, resultando na anexação do GameObject ao seu próprio ponto de colisor.</span><span class="sxs-lookup"><span data-stu-id="26643-240">If the solver GameObject has a collider on one of the layers listed in the `MagneticSurfaces` property of `SurfaceMagnetism`, then the raycast will likely hit itself resulting in the GameObject attaching to its own collider point.</span></span> <span data-ttu-id="26643-241">Esse comportamento inesperado pode ser evitado definindo o GameObject principal e todos os filhos para a camada *Ignorar Raycast* ou modificando a matriz LayerMask `MagneticSurfaces` adequadamente.</span><span class="sxs-lookup"><span data-stu-id="26643-241">This odd behavior can be avoided by setting the main GameObject and all children to the *Ignore Raycast* layer or modifying the `MagneticSurfaces` LayerMask array appropriately.</span></span>

<span data-ttu-id="26643-242">Por outro lado, um GameObject [`SurfaceMagnetism`](xref:Microsoft.MixedReality.Toolkit.Utilities.Solvers.SurfaceMagnetism) não colidirá com superfícies em uma camada não listada na propriedade `MagneticSurfaces`.</span><span class="sxs-lookup"><span data-stu-id="26643-242">Conversely, a [`SurfaceMagnetism`](xref:Microsoft.MixedReality.Toolkit.Utilities.Solvers.SurfaceMagnetism) GameObject will not collide with surfaces on a layer not listed in the `MagneticSurfaces` property.</span></span> <span data-ttu-id="26643-243">Geralmente, é recomendável colocar todas as superfícies desejadas em uma camada dedicada (ou seja,</span><span class="sxs-lookup"><span data-stu-id="26643-243">It is generally recommended to place all desired surfaces on a dedicated layer (i.e</span></span> <span data-ttu-id="26643-244">*Superfícies*) e definir a propriedade `MagneticSurfaces` como apenas esta camada.</span><span class="sxs-lookup"><span data-stu-id="26643-244">*Surfaces*) and setting the `MagneticSurfaces` property to just this layer.</span></span>  <span data-ttu-id="26643-245">Usar o *padrão* ou *tudo* pode resultar em componentes de interface do usuário ou cursores que contribuem para o solucionador.</span><span class="sxs-lookup"><span data-stu-id="26643-245">Using *default* or *everything* may result in UI components or cursors contributing to the solver.</span></span>

<span data-ttu-id="26643-246">Por fim, superfícies mais distantes que a configuração da propriedade `MaxRaycastDistance` serão ignoradas pelos raycasts `SurfaceMagnetism`.</span><span class="sxs-lookup"><span data-stu-id="26643-246">Finally, surfaces farther than the `MaxRaycastDistance` property setting will be ignored by the `SurfaceMagnetism` raycasts.</span></span>

### <a name="directionalindicator"></a><span data-ttu-id="26643-247">DirectionalIndicator</span><span class="sxs-lookup"><span data-stu-id="26643-247">DirectionalIndicator</span></span>

<span data-ttu-id="26643-248">A classe [`DirectionalIndicator`](xref:Microsoft.MixedReality.Toolkit.Utilities.Solvers.DirectionalIndicator) é um componente de marcação voltado para a direção de um ponto desejado no espaço.</span><span class="sxs-lookup"><span data-stu-id="26643-248">The [`DirectionalIndicator`](xref:Microsoft.MixedReality.Toolkit.Utilities.Solvers.DirectionalIndicator) class is a tag-along component that orients itself to the direction of a desired point in space.</span></span>

<span data-ttu-id="26643-249">Mais comumente usado quando o *Tipo de Destino Controlado* do [`SolverHandler`](xref:Microsoft.MixedReality.Toolkit.Utilities.Solvers.SolverHandler) é definido como [`Head`](xref:Microsoft.MixedReality.Toolkit.Utilities.TrackedObjectType.Head).</span><span class="sxs-lookup"><span data-stu-id="26643-249">Most commonly used when the *Tracked Target Type* of the [`SolverHandler`](xref:Microsoft.MixedReality.Toolkit.Utilities.Solvers.SolverHandler) is set to [`Head`](xref:Microsoft.MixedReality.Toolkit.Utilities.TrackedObjectType.Head).</span></span> <span data-ttu-id="26643-250">Dessa forma, um componente de UX com o solucionador [`DirectionalIndicator`](xref:Microsoft.MixedReality.Toolkit.Utilities.Solvers.DirectionalIndicator) direcionará um usuário a olhar  para o ponto desejado.</span><span class="sxs-lookup"><span data-stu-id="26643-250">In this fashion, a UX component with the [`DirectionalIndicator`](xref:Microsoft.MixedReality.Toolkit.Utilities.Solvers.DirectionalIndicator)  solver will direct a user to look at the desired point in space.</span></span>

<span data-ttu-id="26643-251">O ponto desejado é determinado por meio da propriedade *Destino Direcional*.</span><span class="sxs-lookup"><span data-stu-id="26643-251">The desired point in space is determined via the *Directional Target* property.</span></span>

<span data-ttu-id="26643-252">Se o destino direcional puder ser visualizado pelo usuário ou qualquer quadro de referência for definido no [`SolverHandler`](xref:Microsoft.MixedReality.Toolkit.Utilities.Solvers.SolverHandler), esse solucionador desabilitará todos os componentes [`Renderer`](https://docs.unity3d.com/ScriptReference/Renderer.html) abaixo dele.</span><span class="sxs-lookup"><span data-stu-id="26643-252">If the directional target is viewable by the user, or whatever frame of reference is set in the [`SolverHandler`](xref:Microsoft.MixedReality.Toolkit.Utilities.Solvers.SolverHandler), then this solver will disable all [`Renderer`](https://docs.unity3d.com/ScriptReference/Renderer.html) components underneath it.</span></span> <span data-ttu-id="26643-253">Se não for visualizável, tudo será habilitado no indicador.</span><span class="sxs-lookup"><span data-stu-id="26643-253">If not viewable, then everything will be enabled on the indicator.</span></span>

<span data-ttu-id="26643-254">O tamanho do indicador reduzirá quanto mais próximo o usuário estiver de capturar o *Destino Direcional* em seu FOV.</span><span class="sxs-lookup"><span data-stu-id="26643-254">The size of the indicator will shrink the closer the user is to capturing the *Directional Target* in their FOV.</span></span>

* <span data-ttu-id="26643-255">*Escala Mínima de Indicadores* – a escala mínima do objeto indicador</span><span class="sxs-lookup"><span data-stu-id="26643-255">*Min Indicator Scale* - The minimum scale for the indicator object</span></span>
* <span data-ttu-id="26643-256">*Escala Máxima de Indicadores* – a escala máxima do objeto indicador</span><span class="sxs-lookup"><span data-stu-id="26643-256">*Max Indicator Scale* - The maximum scale for the indicator object</span></span>

* <span data-ttu-id="26643-257">*Fator de Escala de Visibilidade* – multiplicador para aumentar ou diminuir o FOV que determina se o ponto do *Destino Direcional* é visualizável ou não</span><span class="sxs-lookup"><span data-stu-id="26643-257">*Visibility Scale Factor* - Multiplier to increase or decrease the FOV that determines if the *Directional Target* point is viewable or not</span></span>
* <span data-ttu-id="26643-258">*Deslocamento de Exibição* – do ponto de vista do quadro de referência (ou seja,</span><span class="sxs-lookup"><span data-stu-id="26643-258">*View Offset* - From the viewpoint of the frame of reference (i.e</span></span> <span data-ttu-id="26643-259">possivelmente a câmera), essa propriedade define a qual distância, na direção do indicador, o objeto deve estar do centro do viewport.</span><span class="sxs-lookup"><span data-stu-id="26643-259">camera possibly), this property defines how far in the indicator direction should the object be from the center of the viewport.</span></span>

<span data-ttu-id="26643-260">![Propriedades do Indicador Direcional](../../images/solver/DirectionalIndicatorExample.png)</span><span class="sxs-lookup"><span data-stu-id="26643-260">![Directional Indicator properties](../../images/solver/DirectionalIndicatorExample.png)</span></span>  
<span data-ttu-id="26643-261">*Propriedades do Indicador Direcional*</span><span class="sxs-lookup"><span data-stu-id="26643-261">*Directional Indicator properties*</span></span>

<span data-ttu-id="26643-262">![Cena de exemplo do Indicador Direcional](../../images/solver/DirectionalIndicatorExampleScene.gif)</span><span class="sxs-lookup"><span data-stu-id="26643-262">![Directional Indicator example scene](../../images/solver/DirectionalIndicatorExampleScene.gif)</span></span>  
<span data-ttu-id="26643-263">*Cena de Exemplo do Indicador Direcional (Assets/MRTK/Examples/Demos/Solvers/Scenes/DirectionalIndicatorSolverExample.unity)*</span><span class="sxs-lookup"><span data-stu-id="26643-263">*Directional Indicator Example Scene (Assets/MRTK/Examples/Demos/Solvers/Scenes/DirectionalIndicatorSolverExample.unity)*</span></span>

### <a name="hand-menu-with-handconstraint-and-handconstraintpalmup"></a><span data-ttu-id="26643-264">Menu lateral com HandConstraint e HandConstraintPalmUp</span><span class="sxs-lookup"><span data-stu-id="26643-264">Hand menu with HandConstraint and HandConstraintPalmUp</span></span>

![Exemplo de UX do Menu Lateral](../../images/solver/MRTK_UX_HandMenu.png)

<span data-ttu-id="26643-266">O comportamento [`HandConstraint`](xref:Microsoft.MixedReality.Toolkit.Utilities.Solvers.HandConstraint) fornece um solucionador que restringe o objeto controlado a uma região segura para conteúdo restrito à mão (como interface do usuário da mão, menus etc.).</span><span class="sxs-lookup"><span data-stu-id="26643-266">The [`HandConstraint`](xref:Microsoft.MixedReality.Toolkit.Utilities.Solvers.HandConstraint) behavior provides a solver that constrains the tracked object to a region safe for hand constrained content (such as hand UI, menus, etc).</span></span> <span data-ttu-id="26643-267">Regiões seguras são consideradas áreas que não se cruzam com a mão.</span><span class="sxs-lookup"><span data-stu-id="26643-267">Safe regions are considered areas that don't intersect with the hand.</span></span> <span data-ttu-id="26643-268">Uma classe derivada de [`HandConstraint`](xref:Microsoft.MixedReality.Toolkit.Utilities.Solvers.HandConstraint) chamada [`HandConstraintPalmUp`](xref:Microsoft.MixedReality.Toolkit.Utilities.Solvers.HandConstraintPalmUp) também é incluída para demonstrar um comportamento comum de ativar o objeto controlado pelo solucionador quando a palma da mão estiver voltada para o usuário.</span><span class="sxs-lookup"><span data-stu-id="26643-268">A derived class of [`HandConstraint`](xref:Microsoft.MixedReality.Toolkit.Utilities.Solvers.HandConstraint) called [`HandConstraintPalmUp`](xref:Microsoft.MixedReality.Toolkit.Utilities.Solvers.HandConstraintPalmUp) is also included to demonstrate a common behavior of activating the solver tracked object when the palm is facing the user.</span></span>

<span data-ttu-id="26643-269">[Consulte a página Menu Lateral](../hand-menu.md) para ver os exemplos de como usar o solucionador de Restrição de Mão para criar menus laterais.</span><span class="sxs-lookup"><span data-stu-id="26643-269">[Please see Hand Menu page](../hand-menu.md) for the examples of using Hand Constraint solver to create hand menus.</span></span>

## <a name="see-also"></a><span data-ttu-id="26643-270">Confira também</span><span class="sxs-lookup"><span data-stu-id="26643-270">See also</span></span>

* [<span data-ttu-id="26643-271">Acompanhamento da Mão</span><span class="sxs-lookup"><span data-stu-id="26643-271">Hand Tracking</span></span>](../../input/hand-tracking.md)
* [<span data-ttu-id="26643-272">Foco</span><span class="sxs-lookup"><span data-stu-id="26643-272">Gaze</span></span>](../../input/gaze.md)
